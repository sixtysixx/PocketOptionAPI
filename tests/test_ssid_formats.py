"""
Test script to demonstrate the updated SSID handling in PocketOption Async API.
This script verifies that the `AsyncPocketOptionClient` can correctly parse
and format session IDs, whether they are provided in the new complete
'42["auth", {...}]' format or as a raw session ID with explicit parameters.
It also simulates the authentication message that would be sent during a real connection.
"""

import asyncio
import json
from pocketoptionapi_async import AsyncPocketOptionClient
from rich.pretty import pprint as print


async def test_ssid_formats():
    """
    Tests the handling of different SSID formats by the AsyncPocketOptionClient.
    It covers:
    1. Initializing the client with a complete SSID string (new format).
    2. Initializing the client with a raw session ID and separate parameters.
    3. Comparing the authentication messages generated by both methods to ensure consistency.
    4. Simulating a connection attempt to demonstrate the flow (expected to fail with dummy data).
    """

    print("Testing SSID Format Handling")
    print("=" * 50)

    # Test 1: Complete SSID format (as typically received from browser login)
    # This string includes the '42["auth",' prefix followed by a JSON object.
    complete_ssid = '42["auth",{"session":"n1p5ah5u8t9438rbunpgrq0hlq","isDemo":1,"uid":72645361,"platform":1,"isFastHistory":true}]'

    print("\n--- Test 1: Initializing with Complete SSID Format ---")
    print(f"Input Complete SSID: {complete_ssid}")

    # Initialize client with the complete SSID. The client's __init__ method
    # is responsible for parsing this string and extracting components.
    client1 = AsyncPocketOptionClient(ssid=complete_ssid)

    # Verify that the internal attributes were correctly parsed from the complete SSID.
    print(f"  Parsed session_id: {client1.session_id}")
    print(f"  Parsed is_demo: {client1.is_demo}")
    print(f"  Parsed UID: {client1.uid}")
    print(f"  Parsed platform: {client1.platform}")
    print(f"  Parsed is_fast_history: {client1.is_fast_history}")

    # Generate the authentication message that the client would send during connection.
    formatted_message1 = client1._format_session_message()
    print(f"  Formatted message (from client1): {formatted_message1}")
    print("-" * 50)

    # Test 2: Raw session ID with explicit parameters
    # This simulates providing only the core session token and other details separately.
    raw_session = "n1p5ah5u8t9438rbunpgrq0hlq"

    print("\n--- Test 2: Initializing with Raw Session ID and Parameters ---")
    print(f"Input Raw Session ID: {raw_session}")

    # Initialize client with the raw session ID and explicit parameters.
    client2 = AsyncPocketOptionClient(
        ssid=raw_session,
        is_demo=True,
        uid=72645361,
        platform=1,
        is_fast_history=True,  # Ensure this matches the complete_ssid for comparison
    )

    # Verify that the internal attributes are set correctly based on the provided parameters.
    print(f"  Set session_id: {client2.session_id}")
    print(f"  Set is_demo: {client2.is_demo}")
    print(f"  Set UID: {client2.uid}")
    print(f"  Set platform: {client2.platform}")
    print(f"  Set is_fast_history: {client2.is_fast_history}")

    # Generate the authentication message from this client instance.
    formatted_message2 = client2._format_session_message()
    print(f"  Formatted message (from client2): {formatted_message2}")
    print("-" * 50)

    # Test 3: Verify both methods produce the same authentication message
    print("\n--- Test 3: Comparing Generated Authentication Messages ---")

    # Helper function to extract and parse the JSON part of the authentication message.
    def extract_auth_data(msg_string):
        """Extracts and JSON-parses the authentication data from a '42["auth",...]' message."""
        try:
            # Find the start of the JSON object after '42["auth",'
            json_start_index = msg_string.find("{")
            # Find the end of the JSON object before the final ']'
            json_end_index = msg_string.rfind("}") + 1
            if json_start_index != -1 and json_end_index > json_start_index:
                json_part = msg_string[json_start_index:json_end_index]
                return json.loads(json_part)
            else:
                raise ValueError("Could not find valid JSON part in message.")
        except (json.JSONDecodeError, ValueError) as e:
            print(f"Error extracting/parsing auth data from message: {e}")
            return {}

    auth_data1 = extract_auth_data(formatted_message1)
    auth_data2 = extract_auth_data(formatted_message2)

    print(f"  Auth data from Complete SSID client: {auth_data1}")
    print(f"  Auth data from Raw Session client:   {auth_data2}")

    # Compare key fields to ensure they are identical.
    fields_to_compare = ["session", "isDemo", "uid", "platform", "isFastHistory"]
    fields_match = True
    for field in fields_to_compare:
        if auth_data1.get(field) != auth_data2.get(field):
            print(
                f"  Mismatch found for field '{field}': {auth_data1.get(field)} vs {auth_data2.get(field)}"
            )
            fields_match = False

    if fields_match:
        print("Both methods produce equivalent authentication data!")
    else:
        print("Authentication data mismatch!")
    print("-" * 50)

    # Test 4: Test connection with a realistic SSID format (mock connection attempt)
    print("\n--- Test 4: Simulating Connection with Complete SSID ---")
    print("  Note: This connection attempt will likely fail as it uses dummy data,")
    print("        but it demonstrates the client's ability to use the formatted SSID.")

    try:
        # Attempt to connect. This will use `formatted_message1` for authentication.
        # This is expected to fail with the dummy SSID but verifies the flow.
        await client1.connect()
        print(
            "Connection simulation successful (unexpected for dummy data, check network)."
        )
    except Exception as e:
        print(f"  Expected connection failure with test data: {e}")
        print("Connection simulation behaved as expected (failed with dummy data).")
    print("-" * 50)

    print("\n\nSSID Format Support Summary:")
    print('  - Complete SSID format: `42["auth",{...}]` - **SUPPORTED**')
    print("  - Raw session ID with parameters - **SUPPORTED**")
    print("  - Automatic parsing and formatting - **WORKING**")
    print("  - UID and platform preservation - **WORKING**")
    print("  - Fast history support - **WORKING**")

    # Show example usage for clarity.
    print("\n\nUsage Examples:")
    print("\n# Method 1 (Recommended): Initialize client with a complete SSID string.")
    print("client = AsyncPocketOptionClient(")
    print(
        '    ssid=\'42["auth",{"session":"your_session_id_here","isDemo":1,"uid":12345,"platform":1,"isFastHistory":true}]\''
    )
    print(")")

    print(
        "\n# Method 2: Initialize client with a raw session ID and explicit parameters."
    )
    print("client = AsyncPocketOptionClient(")
    print("    ssid='your_raw_session_id_here',")
    print("    is_demo=True,")
    print("    uid=12345,")
    print("    platform=1,")
    print("    is_fast_history=True")
    print(")")


async def test_real_connection_simulation():
    """
    Simulates what a real connection setup would look like, focusing on
    how the client processes and prepares the authentication message.
    """

    print("\n\nReal Connection Simulation (Authentication Message Generation)")
    print("=" * 70)

    # Example of a realistic SSID string (dummy session ID for demonstration).
    realistic_ssid = '42["auth",{"session":"a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6","isDemo":1,"uid":72645361,"platform":1,"isFastHistory":true}]'

    # Initialize the client with the realistic SSID.
    client = AsyncPocketOptionClient(ssid=realistic_ssid)

    print("Initialized client with parsed data from realistic SSID:")
    print(f"  Session ID: {client.session_id}")
    print(f"  Is Demo Account: {client.is_demo}")
    print(f"  User ID (UID): {client.uid}")
    print(f"  Platform ID: {client.platform}")
    print(f"  Fast History Enabled: {client.is_fast_history}")

    # Generate the actual authentication message that would be sent during the handshake.
    auth_message_to_send = client._format_session_message()
    print("\nAuthentication message that would be sent to the server:")
    print(f"  {auth_message_to_send}")

    # Parse and display the content of the generated authentication message nicely
    # for verification.
    try:
        # The message is '42["auth", {json_object}]'. We need the json_object part.
        # Find the start of the JSON object.
        json_start = auth_message_to_send.find("{")
        # Find the end of the JSON object.
        json_end = auth_message_to_send.rfind("}") + 1

        if json_start != -1 and json_end > json_start:
            auth_data_parsed = json.loads(auth_message_to_send[json_start:json_end])
            print(
                "\nParsed authentication data from the generated message (for verification):"
            )
            for key, value in auth_data_parsed.items():
                print(f"  {key}: {value}")
        else:
            print("  Could not parse JSON from generated authentication message.")
    except json.JSONDecodeError as e:
        print(f"  Error decoding JSON from generated message: {e}")
    except Exception as e:
        print(f"  An unexpected error occurred during parsing: {e}")

    print("\nThis simulation confirms the client correctly processes the input SSID")
    print(
        "and formats the authentication message as expected for the PocketOption API."
    )
    print("=" * 70)


if __name__ == "__main__":
    # Run the test functions sequentially.
    asyncio.run(test_ssid_formats())
    asyncio.run(test_real_connection_simulation())
